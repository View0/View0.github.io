<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="John Doe" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      STL 
      
      
      |
    
     Kaziro&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/wechat.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">Kaziro</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">STL</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2025-06-28 10:03:11
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/C/" title="C++">
                    #C++
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="STL源码剖析学习笔记"><a href="#STL源码剖析学习笔记" class="headerlink" title="STL源码剖析学习笔记"></a>STL源码剖析学习笔记</h1><ul>
<li>针对SGI-STL</li>
</ul>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL提供六大组件，彼此可以组合套用：</p>
<ol>
<li>容器（containers）：各种数据结构，如vector、list、deque、set、map，用以存放数据。</li>
<li>算法（algorithms）：各种常用算法，如sort、search、copy、erase等。</li>
<li>迭代器（iterators）：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，<mark>所有STL容器都附带有自己专属的迭代器。</mark></li>
<li>仿函数（functors）：行为类似函数，可作为算法的某种策略。</li>
<li>配接器（adapters）：用来修饰容器或仿函数或迭代器接口的东西。</li>
<li>配置器（allocators）：负责空间配置与管理，从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li>
</ol>
<p><img src="/../stl_res/img1.png" alt="image.png"></p>
<h3 id="前闭后开表示法"><a href="#前闭后开表示法" class="headerlink" title="前闭后开表示法"></a>前闭后开表示法</h3><p>任何一个STL算法，都需要获得由一对迭代器（泛型指针）所标示的区间，用以表示操作范围，<mark>这一对迭代器所标示的是前闭后开区间，以<code>[first, last)</code>表示。</mark></p>
<p><img src="/../stl_res/img2.png" alt="image.png"></p>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>整个STL的操作对象（所有的数值）都存放在容器之内，而容器一定需要配置空间以置放资料，故空间配置器allocator极其重要！</p>
<p><mark>内存分配器（allocator）通常需要提供基本的内存分配、释放、构造和销毁等功能。</mark> </p>
<h2 id="SGI空间配置器"><a href="#SGI空间配置器" class="headerlink" title="SGI空间配置器"></a>SGI空间配置器</h2><h3 id="SGI标准的空间配置器：std-allocator"><a href="#SGI标准的空间配置器：std-allocator" class="headerlink" title="SGI标准的空间配置器：std::allocator"></a>SGI标准的空间配置器：<code>std::allocator</code></h3><p><mark>SGI自己从未用过它，也不建议我们使用，主要原因是效率不佳</mark>，它只是把C++的<code>::operator new</code>和<code>::operator delete</code>做一层薄薄的封装而已。</p>
<p><img src="/../stl_res/img3.png" alt="image.png"></p>
<h3 id="SGI特殊的空间配置器：std-alloc"><a href="#SGI特殊的空间配置器：std-alloc" class="headerlink" title="SGI特殊的空间配置器：std::alloc"></a>SGI特殊的空间配置器：<code>std::alloc</code></h3><p>一般而言，我们所习惯的C++内存配置操作和释放操作如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; ... &#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo; <span class="comment">// 配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf; <span class="comment">// 将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>new</code>算式内含两阶段操作：（1）调用<code>::operator new</code>配置内存；（2）调用<code>Foo::Foo()</code>构造对象内容。</li>
<li><code>delete</code>算式也内含两阶段操作：（1）调用<code>Foo::~Foo()</code>将对象析构；（2）调用<code>::operator delete</code>释放内存。</li>
</ul>
<p><mark>为了精密分工，STL allocator决定将这两阶段操作区分开来</mark>，内存配置操作由<code>alloc::allocate()</code>负责，内存释放操作由<code>alloc::deallocate()</code>负责；对象构造操作由<code>::construct()</code>负责，对象析构操作由<code>::destroy()</code>负责。</p>
<p><img src="/../stl_res/img4.png" alt="image.png"></p>
<h3 id="SGI构造和析构的基本工具"><a href="#SGI构造和析构的基本工具" class="headerlink" title="SGI构造和析构的基本工具"></a>SGI构造和析构的基本工具</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stl_construct.h的部分代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (p) <span class="built_in">T1</span>(value); <span class="comment">// placement new；调用T1::T1(value)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy()第一版本，接受一个指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pointer-&gt;~<span class="built_in">T</span>(); <span class="comment">// 调用dtor ~T()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy()第二版本，接受两个迭代器。此函数设法找出元素的数值型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, _ForwardIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __destroy(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值型别value_type是否有trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">    __destroy_aux(first, last, <span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型别有non-trivial destructor（析构函数复杂），逐个销毁对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(; first &lt; last; ++first)</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的数值型别有trivial destructor（析构函数简单，编译器自动处理）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last, __true_type) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy()第二版本针对迭代器为char*和wchar_t*的特化版</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>construct()</code>接受一个指针p和一个初值value，用途就是将初值指定到所指的空间上。</li>
<li><code>destroy()</code>有两个版本，第一个版本接受一个指针，准备将该指针所指之物析构掉。第二个版本接受first和last两个迭代器，准备将<code>[first, last)</code>范围内的所有对象析构掉。（<mark>我们不知道<code>[first, last)</code>范围有多大，万一很大，一次次调用析构函数对效率是一种伤害，因此，首先利用<code>value_type()</code>判断该型别的析构函数是否无关痛痒，若是，则什么也不做就结束，若否（<code>false_type</code>），才以循环的方式遍历整个范围，并对每个对象调用第一个版本的<code>destroy()</code>。</mark>）</li>
</ul>
<h3 id="空间的配置与释放-std-alloc"><a href="#空间的配置与释放-std-alloc" class="headerlink" title="空间的配置与释放 std::alloc"></a>空间的配置与释放 <code>std::alloc</code></h3><ul>
<li>SGI STL以<code>malloc()</code>和<code>free()</code>完成内存的配置与释放。</li>
<li>考虑到小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器直接使用<code>malloc()</code>和<code>free()</code>，第二级配置器则视情况采用不同的策略：<mark>当配置区块超过128bytes时，视之为“足够大”，便调用第一级配置器；当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用复杂的memory pool的整理方式，而不再求助于第一级配置器。</mark></li>
</ul>
<h3 id="第一级配置器剖析"><a href="#第一级配置器剖析" class="headerlink" title="第一级配置器剖析"></a>第一级配置器剖析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 以下都是函数指针，所代表的函数用以处理内存不足的情况</span></span><br><span class="line"><span class="comment">// oom : out of memory</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">oom_realloc</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">malloc</span>(n); <span class="comment">// 第一级配置器直接使用malloc()</span></span><br><span class="line">        <span class="comment">// 以下无法满足需求时，改用oom_malloc()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == result)</span><br><span class="line">            result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* n */</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p); <span class="comment">// 第一级配置器直接使用free()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">void</span> * result = <span class="built_in">realloc</span>(p, new_sz); <span class="comment">// 第一级配置器直接使用realloc()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == result)</span><br><span class="line">            result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下仿真C++的set_new_handler() -&gt; 可以通过它指定自己的out-of-memory handler</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="type">void</span> (*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">void</span> (* old) () = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = f;</span><br><span class="line">        <span class="keyword">return</span> (old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初值为0，有待客端设定</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="built_in">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断尝试释放、配置、再释放、再配置</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler)</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        (*my_alloc_handler)(); <span class="comment">// 调用处理例程，企图释放内存</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n); <span class="comment">// 再次尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> (result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span> * p, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断尝试释放、配置、再释放、再配置</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler)</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        (*my_alloc_handler)(); <span class="comment">// 调用处理例程，企图释放内存</span></span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n); <span class="comment">// 再次尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> (result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将参数inst指定为0</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>

<ul>
<li>SGI第一级配置器的<code>allocate()</code>和<code>realloc()</code>都是在调用<code>malloc()</code>和<code>realloc()</code>不成功后，改调用<code>oom_malloc()</code>和<code>oom_realloc()</code>。<mark>后两者都有内循环，不断调用“内存不足处理例程”，期望在某次调用之后，获得足够的内存而圆满完成任务。</mark>但如果“内存不足处理例程”并未被客端设定，<code>oom_malloc()</code>和<code>oom_realloc()</code>便直接调用<code>__THROW_BAD_ALLOC</code>，丢出bad_alloc异常信息，或利用exit(1)中止程序。</li>
<li>设计、设定“内存不足处理例程”是客端的责任。</li>
</ul>
<h3 id="第二级配置器剖析"><a href="#第二级配置器剖析" class="headerlink" title="第二级配置器剖析"></a>第二级配置器剖析</h3><ul>
<li><code>__default_alloc_template</code></li>
</ul>
<p>SGI第二级配置器的做法是：如果区块勾搭，超过128bytes时，就移交第一级配置器处理。当区块小于128bytes时，则以内存池（memory pool）管理，此法又称为次层配置：<mark>每次配置一大块内存，并维护对应之自由链表<code>free-list</code>。下次再有相同大小的内存需求，就直接从<code>free-lists</code>中取出。</mark>如果客端释还小额区块，就由配置器回收到<code>free-lists</code>中。</p>
<p><img src="/../stl_res/img5.png" alt="image.png"></p>
<h3 id="空间配置函数allocate"><a href="#空间配置函数allocate" class="headerlink" title="空间配置函数allocate()"></a>空间配置函数<code>allocate()</code></h3><ul>
<li>身为一个配置器，<code>__default_alloc_template</code>拥有配置器的标准接口函数<code>allocate()</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">allocate</span>(<span class="type">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    <span class="comment">// 大于128 bytes就调用第一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找16个free lists中适当的一个</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 未找到可用的free list，准备重新填充free list</span></span><br><span class="line">        <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整free list</span></span><br><span class="line">    *my_free_list = result-&gt;free_list_link;</span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间释放函数deallocate"><a href="#空间释放函数deallocate" class="headerlink" title="空间释放函数deallocate()"></a>空间释放函数<code>deallocate()</code></h3><ul>
<li>身为一个配置器，<code>__default_alloc_template</code>拥有配置器的标准接口函数<code>deallocate()</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">deallocate</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    obj *q = (obj *)p;</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于128 bytes就调用第一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">        malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找对应的free list</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    <span class="comment">// 调整free list，回收区块</span></span><br><span class="line">    q-&gt;free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新填充free-lists"><a href="#重新填充free-lists" class="headerlink" title="重新填充free lists"></a>重新填充free lists</h3><ul>
<li>配置器<code>__default_alloc_template</code>的<code>refill()</code>接口。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 调用chunk_alloc() 尝试获取nobjs个区块作为free list的新节点</span></span><br><span class="line">    <span class="type">char</span> * chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);</span><br><span class="line">    obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    obj * current_obj, * next_obj;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只获得一个区块，这个区块就分配给调用者用，free list无新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs)</span><br><span class="line">        <span class="keyword">return</span> (chunk);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则准备调整free list， 纳入新节点</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下在chunk空间内建立free list</span></span><br><span class="line">    result = (obj *) chunk; <span class="comment">// 这一块准备返回给客端</span></span><br><span class="line">    <span class="comment">// 引导free list指向新配置的空间（取自内存池）</span></span><br><span class="line">    *my_free_list = next_obj = (obj *)(chunk + n);</span><br><span class="line">    <span class="comment">// 以下将free list的各节点串接起来</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从1开始，因为第0各将返回给客端</span></span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj*)((<span class="type">char</span> *)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i)</span><br><span class="line">        &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><ul>
<li>从内存池中取空间给free list使用，是<code>chunk_alloc()</code>的工作。</li>
</ul>
<h1 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 - iterator"></a>迭代器 - iterator</h1><p>迭代器（iterators）是一种抽象的设计概念，现实程序语言中没有直接对应于这个概念的实物。《Design Patterns》中iterator模式定义为：提供一种方法，使之能够依序巡访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p>
<h2 id="迭代器的设计思维"><a href="#迭代器的设计思维" class="headerlink" title="迭代器的设计思维"></a>迭代器的设计思维</h2><p>不论是泛型思维或STL的实际运用，迭代器（iterators）都十分重要。<mark>STL的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last &amp;&amp; *first != value)</span><br><span class="line">        ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见的便是内容提领和成员访问，因此，迭代器最重要的编程工作就是对<code>operator*</code>和<code>operator-&gt;</code>进行重载。（<mark>可以参考C++标准程序库中的<code>auto_ptr</code></mark>）</p>
<p>实践：给list（链表）设计一个迭代器</p>
<ol>
<li>其结构如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylist.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListItem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">    <span class="function">ListItem* <span class="title">next</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _next; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _value;</span><br><span class="line">    ListItem* _next; <span class="comment">// 单向链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(std::ostream &amp;os = std::cout)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListItem&lt;T&gt;* _end;</span><br><span class="line">    ListItem&lt;T&gt;* _front;</span><br><span class="line">    <span class="type">long</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>List套用<code>find()</code>，需要设计一个迭代器，如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylist-iter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt; <span class="comment">// Item可以是单向链表节点或双向链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListIter</span> <span class="comment">// 此处这个迭代器特定只为链表服务</span></span><br><span class="line">&#123;</span><br><span class="line">    Item* ptr; <span class="comment">// 保持与容器之间的一个联系</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ListIter</span>(Item* p = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">ptr</span>(p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Item&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    Item* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下两个operator++遵循标准做法</span></span><br><span class="line">    ListIter&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = ptr-&gt;<span class="built_in">next</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListIter <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListIter tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ListIter&amp; i) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr == i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListIter&amp; i) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr != i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>现在可以将List和<code>find()</code>由ListIter粘合起来。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylist-iter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algorithm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本例value类型是int，需要重写全局operator!=重载函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListItem&lt;T&gt;&amp; item, T n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="built_in">value</span>() != n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mylist.<span class="built_in">insert_front</span>(i);</span><br><span class="line">        mylist.<span class="built_in">insert_end</span>(i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">display</span>(); <span class="comment">// 10 ( 4 3 2 1 0 2 3 4 5 6)</span></span><br><span class="line"></span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">begin</span>(mylist.<span class="built_in">front</span>());</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt;&gt; end; <span class="comment">// default 0, null</span></span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="type">int</span>&gt;&gt; iter; <span class="comment">// default 0, null</span></span><br><span class="line"></span><br><span class="line">    iter = <span class="built_in">find</span>(begin, end, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter == end)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;found.&quot;</span> &lt;&lt; iter-&gt;<span class="built_in">value</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    iter = <span class="built_in">find</span>(begin, end, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter == end)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;found.&quot;</span> &lt;&lt; iter-&gt;<span class="built_in">value</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了完成一个针对List而设计的迭代器，无可避免地暴露了太多List实现细节：在<code>main()</code>之中为了制作begin和end两个迭代器，暴露了ListItem；在ListIter class之中为了达成operator++的目的，暴露了ListItem的操作函数<code>next()</code>。<mark>要设计出ListIter，首先必须要对List的实现细节有非常丰富的了解。为了封装实现细节，STL容器都有专属迭代器！</mark></li>
</ul>
<h2 id="迭代器相应型别"><a href="#迭代器相应型别" class="headerlink" title="迭代器相应型别"></a>迭代器相应型别</h2><p>迭代器相应型别不只是“迭代器所指对象的型别”一种而已。根据经验，最常用的相应型别有五种。</p>
<h1 id="Traits编程技法"><a href="#Traits编程技法" class="headerlink" title="Traits编程技法"></a>Traits编程技法</h1><p>迭代器所指对象的型别，称为该迭代器的value type。<mark>但函数的template参数推导机制推而导之的只是参数，无法推导函数的回返值型别。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明内嵌型别方法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别声明</span></span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="built_in">MyIter</span>(T* p = <span class="number">0</span>) : <span class="built_in">ptr</span>(p) &#123; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>traits</strong>：如果I有自己的value type，那么通过这个traits的作用，萃取出来的value_type就是I::value_type。</p>
<p><img src="/../stl_res/img6.png" alt="image.png"></p>
<p>最常用到的迭代器相应型别有五种</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器相应型别之一-value-type"><a href="#迭代器相应型别之一-value-type" class="headerlink" title="迭代器相应型别之一 value type"></a>迭代器相应型别之一 value type</h2><p>所谓value type，是指迭代器所指对象的型别。</p>
<h2 id="迭代器相应型别之二-difference-type"><a href="#迭代器相应型别之二-difference-type" class="headerlink" title="迭代器相应型别之二 difference type"></a>迭代器相应型别之二 difference type</h2><p>difference type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL的count()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type <span class="comment">// 这一整行是函数回返型别</span></span><br><span class="line"><span class="built_in">count</span> (I first, I last, <span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (*first == value)</span><br><span class="line">            ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器型别之三-reference-type"><a href="#迭代器型别之三-reference-type" class="headerlink" title="迭代器型别之三 reference type"></a>迭代器型别之三 reference type</h2><p>在C++中，函数如果要传回左值，都是以by reference的方式进行，所以当p十个mutable iterator时，如果其value type是T，那么<code>*p</code>的型别不应该是<code>T</code>，应该是<code>T&amp;</code>。如果p是一个constant iterators，其value type是T，那么<code>*p</code>的型别不应该是<code>cosnt T</code>，而应该是<code>const T&amp;</code>。此处讨论的*p的型别，即所谓的reference type。</p>
<h2 id="迭代器型别之四-pointer-type"><a href="#迭代器型别之四-pointer-type" class="headerlink" title="迭代器型别之四 pointer type"></a>迭代器型别之四 pointer type</h2><p>传回左值时，传回一个pointer，指向迭代器所指之物。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Item&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125; <span class="comment">// Item&amp; 是ListIter的reference type</span></span><br><span class="line">Item* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125; <span class="comment">// Item* 是ListIter的pointer type</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计适当的相应型别，是迭代器的责任。设计适当的迭代器，则是容器的责任。（只有容器本身，才知道该设计出怎样的迭代器来遍历自己。）</p>
<p>traits编程大量运用于STL实现品中，它利用“内嵌型别”的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力。</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><p><img src="/../stl_res/img7.png" alt="image.png"></p>
<p>所谓序列式容器，其中的元素都可序，但未必有序。C++语言本身提供了一个序列式的容器array，STL另外提供vector、list、deque、stack、queue、priority-queue等序列式容器。(<mark>严格来说stack、queue等都是容器配接器！</mark>)</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>vector是<mark>动态空间</mark>，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。</li>
</ul>
<h3 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a>vector的迭代器</h3><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，普通指针都可以作为vector的迭代器而满足所有必要条件，因为vector迭代器需要的操作行为，如<code>operator*</code>、<code>operator-&gt;</code>等，普通指针天生就具备。<mark>vector支持随机存取。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator; <span class="comment">// vector的迭代器是普通指针</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若客端代码如下，则<code>ivite</code>的型别其实就是<code>int*</code>，<code>svite</code>的型别其实就是<code>Shape*</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator ivite;</span><br><span class="line">vector&lt;Shape&gt;::iterator svite;</span><br></pre></td></tr></table></figure>

<h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h3><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求量大一些，以备将来可能的扩充。<mark>这便是容量（capacity），一个vector的容量永远大于或者等于其大小。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start; <span class="comment">// 目前使用空间的头</span></span><br><span class="line">    iterator finish; <span class="comment">// 目前使用空间的尾</span></span><br><span class="line">    iterator end_of_storage; <span class="comment">// 目前可用空间的尾</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运用start、finish、end_of_storage三个迭代器，便可轻易地提供首尾标示、大小等机能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[] (size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/../stl_res/img8.png" alt="image.png"></p>
<h3 id="vector的构造和内存管理"><a href="#vector的构造和内存管理" class="headerlink" title="vector的构造和内存管理"></a>vector的构造和内存管理</h3><p>vector提供许多constructors，其中一个允许我们指定空间大小及初值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，允许指定vector大小n和初值value</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充并予以初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置而后填充</span></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iterator result = data_allocator::<span class="built_in">allocate</span>(n); <span class="comment">// 配置n个元素空间</span></span><br><span class="line">    <span class="built_in">uninitialized_fill_n</span>(result, n, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>push_back()</code>将新元素插入于vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器finish，使vector变大；如果没有备用空间就扩充空间（2倍扩容）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 有备用空间</span></span><br><span class="line">        <span class="built_in">construct</span>(finish, x);</span><br><span class="line">        ++finish; <span class="comment">// 调整水位高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 无备用空间，需要扩容</span></span><br><span class="line">        <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 有备用空间</span></span><br><span class="line">        <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">        ++finish; <span class="comment">// 调整水位</span></span><br><span class="line">        T x_copy = x;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *positioon = x_copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已无备用空间</span></span><br><span class="line">        <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 若原大小为0，则配置1个元素大小</span></span><br><span class="line">        <span class="comment">// 若原大小不为0，则二倍扩容</span></span><br><span class="line">        <span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        iterator new_start = data_allocator::<span class="built_in">allocate</span>(len); <span class="comment">// 实际配置</span></span><br><span class="line">        <span class="built_in">construct</span>(new_finish, x); <span class="comment">// 为新元素设定初值x</span></span><br><span class="line">        ++new_finish;</span><br><span class="line">        <span class="comment">// 将原vector的备用空间中的内容也拷贝过来（？）</span></span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构并释放原vector</span></span><br><span class="line">    <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整迭代器，指向新vector</span></span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>所谓动态增加大小，并不是在原空间之后连续新空间</mark>（因为无法保证原空间之后尚有可配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>相比于vector的连续线性空间，list就显得复杂许多。<mark>它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。</mark>list对于空间的运用绝对精准，一点也不浪费。</li>
</ul>
<h3 id="list的节点（node）"><a href="#list的节点（node）" class="headerlink" title="list的节点（node）"></a>list的节点（node）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实质是一个双向链表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev; <span class="comment">// 型别为void*</span></span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>list不能用普通指针作为迭代器，因为其节点不保证在存储空间中连续存在。</li>
</ul>
<h3 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h3><p>SGI list不仅是一个双向链表，而且还是一个环状双向链表。（只需一个指针，便可以完整表现整个链表。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node; <span class="comment">// 只要一个指针，便可表示整个环状双向链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/../stl_res/img9.png" alt="image.png"></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><ul>
<li>vector是单向开口的连续线性空间，deque则是双向开口的连续线性空间。</li>
<li>deque允许常数时间内对头端进行元素的插入与移除操作。</li>
<li>deque没有所谓容量（capacity）观念，它是动态地分段连续空间组合而成。</li>
<li>除非必要，应尽可能选用vector而非deque。</li>
</ul>
<p><img src="/../stl_res/img10.png" alt="image.png"></p>
<p><mark>deque逻辑上是连续空间，实际是由一段一段的定量连续空间构成。</mark>一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。无需维护整体连续，但代价是<mark>复杂的迭代器架构。</mark></p>
<p><img src="/../stl_res/img11.png" alt="image.png"></p>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><p>deque的迭代器（<mark>较为复杂</mark>）必须能够指出分段连续空间（亦即缓冲区）在哪里；必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start; <span class="comment">// 第一个节点</span></span><br><span class="line">    iterator finish; <span class="comment">// 最后一个节点</span></span><br><span class="line"></span><br><span class="line">    map_pointer map; <span class="comment">// 指向map</span></span><br><span class="line"></span><br><span class="line">    size_type map_size; <span class="comment">// map内有多少指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><ul>
<li>stack是一种“先进后出”（FILO）的数据结构。</li>
<li>stack除了最顶端外，没有任何其它方法可以存取stack的其它元素。换言之，stack不允许所有遍历行为。</li>
<li>stack不提供走访功能，也不提供迭代器。</li>
</ul>
<p><img src="/../stl_res/img12.png" alt="image.png"></p>
<h3 id="stack的实现"><a href="#stack的实现" class="headerlink" title="stack的实现"></a>stack的实现</h3><p><mark>stack以底部容器完成其所有工作，因此STL stack往往不被归类为container，而被归类为container adapter。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 完全利用Sequence c的操作，完成stack的操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><ul>
<li>queue是一种“先进先出”（FIFO）的数据结构。</li>
<li>queue除了最顶端可以取出、最低端可以加入外，没有任何其它方法可以存取queue的其它元素。换言之，queue不允许所有遍历行为。</li>
<li>queue亦不提供迭代器。</li>
</ul>
<p><img src="/../stl_res/img13.png" alt="image.png"></p>
<h3 id="queue的实现"><a href="#queue的实现" class="headerlink" title="queue的实现"></a>queue的实现</h3><p><mark>queue以底部容器完成其所有工作，因此STL queue往往不被归类为container，而被归类为container adapter。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 完全利用Sequence c的操作，完成queue的操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul>
<li>拥有权值观念的queue，其内的元素并非按照被推入的次序排列，而是自动依照元素的权值排列。</li>
<li>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素才有机会被外界取用。</li>
</ul>
<h3 id="priority-queue的实现"><a href="#priority-queue的实现" class="headerlink" title="priority_queue的实现"></a>priority_queue的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line">        <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x) : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last) : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将新元素推入末端</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="comment">// 重排heap</span></span><br><span class="line">        <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p>所谓关联式容器，观念上类似关联式数据库：每笔数据（每个元素）都有一个键值和一个实值。一般而言，关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜索效率。</p>
<h2 id="红黑树-RB-tree"><a href="#红黑树-RB-tree" class="headerlink" title="红黑树 RB-tree"></a>红黑树 RB-tree</h2><p>RB-tree不仅是一个二叉搜索树，而且必须满足以下规则：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点为黑色。</li>
<li>如果节点为红，其子节点必须为黑。</li>
<li>任一节点至NULL（树尾端）的任何路径，所含之黑节点数必须相同。</li>
</ol>
<p><img src="/../stl_res/img14.png" alt="image.png"></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法，问题之解法也。</p>
<h2 id="质变算法"><a href="#质变算法" class="headerlink" title="质变算法"></a>质变算法</h2><p>所有的STL算法都作用在由迭代器<code>[first, last)</code>所标出来的区间上，质变算法即指运算过程中会更改区间内（迭代器所指）的元素内容。诸如拷贝copy、互换swap、替换replace等。</p>
<ul>
<li><mark>这类算法运用于一个常数区间上会报错！</mark></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123; <span class="number">22</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">33</span>, <span class="number">40</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator cite1 = iv.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator cite2 = iv.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(cite1, cite2); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h2 id="非质变算法"><a href="#非质变算法" class="headerlink" title="非质变算法"></a>非质变算法</h2><p>所有的STL算法都作用在由迭代器<code>[first, last)</code>所标出来的区间上，非质变算法即指运算过程中不会更改区间内（迭代器所指）的元素内容。诸如查找find、计数count、巡防for_each等。</p>
<ul>
<li><mark>这类算法应用一个会改变元素的仿函数，则元素当然会改变！</mark></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T&amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; x += <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ia[] = &#123; <span class="number">22</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">17</span>, <span class="number">33</span>, <span class="number">40</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">plus2</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用T所提供的greater-than操作符来判断大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用仿函数comp来判断大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">comp</span>(a, b) ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="仿函数-functors"><a href="#仿函数-functors" class="headerlink" title="仿函数 - functors"></a>仿函数 - functors</h1><p>一种具有函数特质的对象，其实就是一个“行为类似函数”的对象，其类别定义中必须自定义function call运算子 - operator()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    greater&lt;<span class="type">int</span>&gt; ig;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">ig</span>(<span class="number">4</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()(<span class="number">6</span>, <span class="number">4</span>); <span class="comment">// true - greater&lt;int&gt;()产生临时对象 (4, 6)指定两个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算术类仿函数"><a href="#算术类仿函数" class="headerlink" title="算术类仿函数"></a>算术类仿函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 否定为一元运算，其它都是二元运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法、减法minus、乘法multiplies、除法divides、模取modulus类似</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">modulus</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">negate</span> : <span class="keyword">public</span> unary_function&lt;T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="配接器-adapters"><a href="#配接器-adapters" class="headerlink" title="配接器 - adapters"></a>配接器 - adapters</h1><p>配接器在STL组件的灵活组合运用功能上，扮演着轴承、转换器的角色。(<mark>将一个class的接口转换为另一个class的接口，使原本不兼容而不能合作的classes，可以一起运作。</mark>)</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/12/23/MySQL%E5%9F%BA%E7%A1%80/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2025-06-28 10:03:11
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/C/" title="C++">
                        #C++
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2025/02/27/MySQL%E8%BF%9E%E6%8E%A5%E6%B1%A0/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">STL源码剖析学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">STL六大组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E9%97%AD%E5%90%8E%E5%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">前闭后开表示法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-text">空间配置器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SGI%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-text">SGI空间配置器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SGI%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%EF%BC%9Astd-allocator"><span class="toc-text">SGI标准的空间配置器：std::allocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SGI%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%EF%BC%9Astd-alloc"><span class="toc-text">SGI特殊的空间配置器：std::alloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SGI%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7"><span class="toc-text">SGI构造和析构的基本工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%87%8A%E6%94%BE-std-alloc"><span class="toc-text">空间的配置与释放 std::alloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8%E5%89%96%E6%9E%90"><span class="toc-text">第一级配置器剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8%E5%89%96%E6%9E%90"><span class="toc-text">第二级配置器剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%87%BD%E6%95%B0allocate"><span class="toc-text">空间配置函数allocate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0deallocate"><span class="toc-text">空间释放函数deallocate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%A1%AB%E5%85%85free-lists"><span class="toc-text">重新填充free lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-text">内存池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator"><span class="toc-text">迭代器 - iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4"><span class="toc-text">迭代器的设计思维</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%B8%80%E7%A7%8Dsmart-pointer"><span class="toc-text">迭代器是一种smart pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB"><span class="toc-text">迭代器相应型别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95"><span class="toc-text">Traits编程技法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%B8%80-value-type"><span class="toc-text">迭代器相应型别之一 value type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%BA%8C-difference-type"><span class="toc-text">迭代器相应型别之二 difference type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9E%8B%E5%88%AB%E4%B9%8B%E4%B8%89-reference-type"><span class="toc-text">迭代器型别之三 reference type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9E%8B%E5%88%AB%E4%B9%8B%E5%9B%9B-pointer-type"><span class="toc-text">迭代器型别之四 pointer type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">vector的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">vector的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">vector的构造和内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88node%EF%BC%89"><span class="toc-text">list的节点（node）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">list的数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque"><span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">deque的数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack"><span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stack%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">stack的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue"><span class="toc-text">queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">queue的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priority-queue"><span class="toc-text">priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#priority-queue%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">priority_queue的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-RB-tree"><span class="toc-text">红黑树 RB-tree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E5%8F%98%E7%AE%97%E6%B3%95"><span class="toc-text">质变算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%B4%A8%E5%8F%98%E7%AE%97%E6%B3%95"><span class="toc-text">非质变算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">算法示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0-functors"><span class="toc-text">仿函数 - functors</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">算术类仿函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E6%8E%A5%E5%99%A8-adapters"><span class="toc-text">配接器 - adapters</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + STL + '&url=' + http%3A%2F%2Fexample.com%2F2025%2F02%2F19%2FSTL%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2025/02/19/STL/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
